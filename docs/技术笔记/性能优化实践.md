# Web 性能优化实战指南

## 前端性能优化

### 资源加载优化
```html
<!-- 预加载关键资源 -->
<link rel="preload" href="critical.css" as="style">
<link rel="preload" href="app.js" as="script">

<!-- 预连接重要域名 -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="dns-prefetch" href="https://cdn.example.com">

<!-- 懒加载非关键资源 -->
<img src="placeholder.jpg" data-src="real-image.jpg" loading="lazy">
<script src="non-critical.js" defer></script>

<!-- 资源提示 -->
<link rel="prefetch" href="next-page.html">
<link rel="prerender" href="next-page.html">
```

### JavaScript 优化
```javascript
// 防抖和节流
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function throttle(func, limit) {
    let inThrottle;
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// 虚拟列表（处理大数据）
class VirtualList {
    constructor(container, items, itemHeight, renderItem) {
        this.container = container;
        this.items = items;
        this.itemHeight = itemHeight;
        this.renderItem = renderItem;
        this.visibleItems = [];
        
        this.init();
    }
    
    init() {
        this.container.style.height = `${this.items.length * this.itemHeight}px`;
        this.container.addEventListener('scroll', this.handleScroll.bind(this));
        this.renderVisibleItems();
    }
    
    handleScroll() {
        this.renderVisibleItems();
    }
    
    renderVisibleItems() {
        const scrollTop = this.container.scrollTop;
        const startIndex = Math.floor(scrollTop / this.itemHeight);
        const endIndex = Math.min(
            startIndex + Math.ceil(this.container.clientHeight / this.itemHeight) + 5,
            this.items.length
        );
        
        // 复用 DOM 元素
        this.visibleItems = this.items.slice(startIndex, endIndex);
        this.updateDOM(startIndex);
    }
    
    updateDOM(startIndex) {
        // 更新可见项的位置和内容
        // 实现 DOM 复用逻辑
    }
}
```

### CSS 性能优化
```css
/* 减少重排重绘 */
.optimized-element {
    transform: translateZ(0);
    will-change: transform;
}

/* 使用 CSS Containment */
.isolated-component {
    contain: layout style paint;
}

/* 优化动画性能 */
.smooth-animation {
    transform: translate3d(0, 0, 0);
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* 减少选择器复杂度 */
/* 不好 */
div > ul > li > a .icon { }

/* 好 */
.nav-icon { }

/* 使用 CSS 变量 */
:root {
    --primary-color: #007bff;
    --spacing-unit: 8px;
}

.btn {
    background-color: var(--primary-color);
    padding: calc(var(--spacing-unit) * 2);
}
```

## 后端性能优化

### 数据库查询优化
```python
# Django 查询优化
from django.db import models
from django.db.models import Prefetch

class User(models.Model):
    name = models.CharField(max_length=100)

class Order(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    amount = models.DecimalField(max_digits=10, decimal_places=2)

# 避免 N+1 查询问题
# 不好
users = User.objects.all()
for user in users:
    orders = user.order_set.all()  # 每次循环都查询数据库

# 好
users = User.objects.prefetch_related('order_set').all()

# 使用 select_related 和 prefetch_related
orders = Order.objects.select_related('user').prefetch_related('items').all()

# 使用 values() 和 values_list() 减少内存使用
user_emails = User.objects.values_list('email', flat=True)
```

### 缓存策略实现
```python
import redis
from django.core.cache import cache
from functools import wraps

def cached_view(timeout=300):
    """视图缓存装饰器"""
    def decorator(view_func):
        @wraps(view_func)
        def _wrapped_view(request, *args, **kwargs):
            cache_key = f"view:{request.path}:{request.GET.urlencode()}"
            
            # 尝试从缓存获取
            response = cache.get(cache_key)
            if response is None:
                response = view_func(request, *args, **kwargs)
                # 只缓存成功的响应
                if response.status_code == 200:
                    cache.set(cache_key, response, timeout)
            return response
        return _wrapped_view
    return decorator

class QueryCacheMixin:
    """查询缓存 Mixin"""
    
    def get_cache_key(self):
        """生成缓存键"""
        return f"query:{self.__class__.__name__}:{self.kwargs}"
    
    def get_queryset(self):
        cache_key = self.get_cache_key()
        cached_data = cache.get(cache_key)
        
        if cached_data is not None:
            return cached_data
        
        queryset = super().get_queryset()
        cache.set(cache_key, queryset, timeout=300)
        return queryset
```

### 异步任务处理
```python
# Celery 任务优化
from celery import Celery
from django.core.cache import cache

app = Celery('myapp')

@app.task(bind=True, max_retries=3)
def process_large_file(self, file_path):
    """处理大文件的异步任务"""
    try:
        # 分块处理大文件
        chunk_size = 1000
        with open(file_path, 'r') as file:
            while True:
                chunk = file.readlines(chunk_size)
                if not chunk:
                    break
                process_chunk.delay(chunk)
        
        # 更新进度
        cache.set(f'task_progress:{self.request.id}', 100, 300)
        
    except Exception as exc:
        # 指数退避重试
        raise self.retry(countdown=2 ** self.request.retries, exc=exc)

@app.task
def process_chunk(chunk):
    """处理数据块"""
    for line in chunk:
        # 处理每一行数据
        process_line(line)
```

## 网络优化

### HTTP/2 优化
```nginx
# nginx 配置
server {
    listen 443 ssl http2;
    server_name example.com;
    
    # 启用 HTTP/2
    http2 on;
    
    # 启用服务器推送
    location = /index.html {
        http2_push /style.css;
        http2_push /app.js;
    }
    
    # 启用 Gzip 压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css application/json application/javascript;
    
    # 缓存静态资源
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
```

### CDN 配置优化
```javascript
// 动态资源版本控制
function loadScript(src) {
    const version = 'v1.2.3'; // 构建时生成
    const url = `${src}?v=${version}`;
    
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = url;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
    });
}

// 资源监控
class ResourceMonitor {
    constructor() {
        this.entries = [];
        this.observeResources();
    }
    
    observeResources() {
        if ('PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                list.getEntries().forEach(entry => {
                    this.entries.push(entry);
                    this.analyzeResource(entry);
                });
            });
            
            observer.observe({ entryTypes: ['resource'] });
        }
    }
    
    analyzeResource(entry) {
        if (entry.duration > 1000) {
            console.warn('Slow resource loading:', entry.name);
        }
    }
}
```

## 监控与分析

### 性能监控
```javascript
// 核心 Web 指标监控
class PerformanceMonitor {
    constructor() {
        this.metrics = {};
        this.observeCoreWebVitals();
    }
    
    observeCoreWebVitals() {
        // 监控 LCP (Largest Contentful Paint)
        new PerformanceObserver((entryList) => {
            const entries = entryList.getEntries();
            const lastEntry = entries[entries.length - 1];
            this.metrics.LCP = lastEntry.renderTime || lastEntry.loadTime;
        }).observe({ type: 'largest-contentful-paint', buffered: true });
        
        // 监控 FID (First Input Delay)
        new PerformanceObserver((entryList) => {
            const entries = entryList.getEntries();
            entries.forEach(entry => {
                this.metrics.FID = entry.processingStart - entry.startTime;
            });
        }).observe({ type: 'first-input', buffered: true });
        
        // 监控 CLS (Cumulative Layout Shift)
        let clsValue = 0;
        new PerformanceObserver((entryList) => {
            for (const entry of entryList.getEntries()) {
                if (!entry.hadRecentInput) {
                    clsValue += entry.value;
                }
            }
            this.metrics.CLS = clsValue;
        }).observe({ type: 'layout-shift', buffered: true });
    }
    
    reportMetrics() {
        // 上报性能数据
        navigator.sendBeacon('/api/performance', this.metrics);
    }
}
```

### 错误监控
```javascript
// 前端错误监控
class ErrorMonitor {
    constructor() {
        this.setupErrorHandling();
    }
    
    setupErrorHandling() {
        // 捕获 JavaScript 错误
        window.addEventListener('error', (event) => {
            this.reportError({
                type: 'javascript',
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                stack: event.error?.stack
            });
        });
        
        // 捕获 Promise 拒绝
        window.addEventListener('unhandledrejection', (event) => {
            this.reportError({
                type: 'promise',
                reason: event.reason?.toString(),
                stack: event.reason?.stack
            });
        });
        
        // 捕获资源加载错误
        window.addEventListener('error', (event) => {
            if (event.target && event.target.src) {
                this.reportError({
                    type: 'resource',
                    tag: event.target.tagName,
                    url: event.target.src || event.target.href
                });
            }
        }, true);
    }
    
    reportError(errorInfo) {
        const errorData = {
            ...errorInfo,
            url: window.location.href,
            userAgent: navigator.userAgent,
            timestamp: new Date().toISOString()
        };
        
        // 上报错误信息
        navigator.sendBeacon('/api/errors', errorData);
    }
}
```

## 优化检查清单

### 前端优化
- [ ] 图片优化（WebP、懒加载）
- [ ] 代码分割和懒加载
- [ ] 资源压缩和最小化
- [ ] 使用 HTTP/2 和 CDN
- [ ] 核心 Web 指标优化

### 后端优化
- [ ] 数据库查询优化
- [ ] 缓存策略实施
- [ ] 异步任务处理
- [ ] 连接池配置
- [ ] 负载均衡

### 网络优化
- [ ] 启用 Gzip 压缩
- [ ] 配置合适的缓存头
- [ ] 使用 HTTP/2
- [ ] DNS 预解析
- [ ] 减少重定向

### 监控优化
- [ ] 性能监控设置
- [ ] 错误监控配置
- [ ] 业务指标跟踪
- [ ] 用户行为分析
- [ ] 告警机制建立

> **💡 性能优化原则**：
> 1. 测量优先 - 没有测量就没有优化
> 2. 用户体验至上 - 关注真实用户指标
> 3. 渐进式优化 -