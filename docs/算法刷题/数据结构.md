# 算法模板库

## 二分查找模板

### 标准二分查找
```python
def binary_search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

### 寻找左边界
```python
def left_bound(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return left if left < len(nums) and nums[left] == target else -1
```

## 二叉树遍历

### 递归遍历
```javascript
// 前序遍历
function preorderTraversal(root) {
  const result = [];
  
  function traverse(node) {
    if (!node) return;
    result.push(node.val);    // 访问根节点
    traverse(node.left);      // 遍历左子树
    traverse(node.right);     // 遍历右子树
  }
  
  traverse(root);
  return result;
}
```

### 迭代遍历
```javascript
// 前序遍历 - 迭代版本
function preorderTraversal(root) {
  if (!root) return [];
  
  const stack = [root];
  const result = [];
  
  while (stack.length) {
    const node = stack.pop();
    result.push(node.val);
    
    // 先右后左，保证左子树先出栈
    if (node.right) stack.push(node.right);
    if (node.left) stack.push(node.left);
  }
  
  return result;
}
```

## 动态规划模板

### 背包问题
```python
def knapsack(weights, values, capacity):
    n = len(weights)
    # dp[i][w] 表示前i个物品，背包容量为w时的最大价值
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i-1] <= w:
                # 选择当前物品或不选择
                dp[i][w] = max(
                    dp[i-1][w], 
                    dp[i-1][w - weights[i-1]] + values[i-1]
                )
            else:
                dp[i][w] = dp[i-1][w]
    
    return dp[n][capacity]
```

## 复杂度分析

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|------------|------------|----------|
| 二分查找 | O(log n) | O(1) | 有序数组查找 |
| 快速排序 | O(n log n) | O(log n) | 通用排序 |
| 二叉树遍历 | O(n) | O(h) | 树结构处理 |

# 数据结构全面总结

## 数组与字符串

### 双指针技巧
```python
# 快慢指针 - 删除有序数组重复项
def remove_duplicates(nums):
    if not nums:
        return 0
    
    slow = 0
    for fast in range(1, len(nums)):
        if nums[fast] != nums[slow]:
            slow += 1
            nums[slow] = nums[fast]
    
    return slow + 1

# 左右指针 - 两数之和
def two_sum(numbers, target):
    left, right = 0, len(numbers) - 1
    while left < right:
        total = numbers[left] + numbers[right]
        if total == target:
            return [left + 1, right + 1]
        elif total < target:
            left += 1
        else:
            right -= 1
    return [-1, -1]
```

### 滑动窗口
```python
# 无重复字符的最长子串
def length_of_longest_substring(s):
    window = set()
    left = 0
    max_len = 0
    
    for right in range(len(s)):
        while s[right] in window:
            window.remove(s[left])
            left += 1
        window.add(s[right])
        max_len = max(max_len, right - left + 1)
    
    return max_len

# 最小覆盖子串
def min_window(s, t):
    from collections import Counter
    
    need = Counter(t)
    window = Counter()
    left = right = 0
    valid = 0
    start = 0
    min_len = float('inf')
    
    while right < len(s):
        c = s[right]
        right += 1
        
        if c in need:
            window[c] += 1
            if window[c] == need[c]:
                valid += 1
        
        while valid == len(need):
            if right - left < min_len:
                start = left
                min_len = right - left
            
            d = s[left]
            left += 1
            
            if d in need:
                if window[d] == need[d]:
                    valid -= 1
                window[d] -= 1
    
    return "" if min_len == float('inf') else s[start:start + min_len]
```

## 链表

### 基础操作
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

# 反转链表
def reverse_list(head):
    prev = None
    curr = head
    
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    
    return prev

# 递归反转
def reverse_list_recursive(head):
    if not head or not head.next:
        return head
    
    new_head = reverse_list_recursive(head.next)
    head.next.next = head
    head.next = None
    
    return new_head
```

### 快慢指针应用
```python
# 检测环
def has_cycle(head):
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    
    return False

# 找到环的入口
def detect_cycle(head):
    slow = fast = head
    has_cycle = False
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            has_cycle = True
            break
    
    if not has_cycle:
        return None
    
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    
    return slow

# 找到中间节点
def find_middle(head):
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow
```

## 栈与队列

### 单调栈
```python
# 下一个更大元素
def next_greater_element(nums):
    stack = []
    result = [-1] * len(nums)
    
    for i in range(len(nums)):
        while stack and nums[i] > nums[stack[-1]]:
            idx = stack.pop()
            result[idx] = nums[i]
        stack.append(i)
    
    return result

# 每日温度
def daily_temperatures(temperatures):
    stack = []
    result = [0] * len(temperatures)
    
    for i in range(len(temperatures)):
        while stack and temperatures[i] > temperatures[stack[-1]]:
            idx = stack.pop()
            result[idx] = i - idx
        stack.append(i)
    
    return result
```

### 优先队列
```python
import heapq

# 前 K 个高频元素
def top_k_frequent(nums, k):
    from collections import Counter
    
    count = Counter(nums)
    heap = []
    
    for num, freq in count.items():
        heapq.heappush(heap, (freq, num))
        if len(heap) > k:
            heapq.heappop(heap)
    
    return [num for freq, num in heap]

# 数据流的中位数
class MedianFinder:
    def __init__(self):
        self.small = []  # 最大堆，存储较小的一半
        self.large = []  # 最小堆，存储较大的一半

    def addNum(self, num):
        heapq.heappush(self.small, -num)
        
        # 平衡两个堆
        if (self.small and self.large and 
            -self.small[0] > self.large[0]):
            val = -heapq.heappop(self.small)
            heapq.heappush(self.large, val)
        
        # 调整大小
        if len(self.small) > len(self.large) + 1:
            val = -heapq.heappop(self.small)
            heapq.heappush(self.large, val)
        elif len(self.large) > len(self.small):
            val = heapq.heappop(self.large)
            heapq.heappush(self.small, -val)

    def findMedian(self):
        if len(self.small) > len(self.large):
            return -self.small[0]
        return (-self.small[0] + self.large[0]) / 2
```

## 树结构

### 二叉树遍历
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 迭代遍历
def preorder_traversal(root):
    if not root:
        return []
    
    stack = [root]
    result = []
    
    while stack:
        node = stack.pop()
        result.append(node.val)
        
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    
    return result

def inorder_traversal(root):
    stack = []
    result = []
    curr = root
    
    while curr or stack:
        while curr:
            stack.append(curr)
            curr = curr.left
        
        curr = stack.pop()
        result.append(curr.val)
        curr = curr.right
    
    return result
```

### 二叉搜索树
```python
# 验证二叉搜索树
def is_valid_bst(root):
    def validate(node, low=float('-inf'), high=float('inf')):
        if not node:
            return True
        
        if node.val <= low or node.val >= high:
            return False
        
        return (validate(node.left, low, node.val) and 
                validate(node.right, node.val, high))
    
    return validate(root)

# BST 迭代器
class BSTIterator:
    def __init__(self, root):
        self.stack = []
        self._leftmost_inorder(root)
    
    def _leftmost_inorder(self, node):
        while node:
            self.stack.append(node)
            node = node.left
    
    def next(self):
        topmost_node = self.stack.pop()
        
        if topmost_node.right:
            self._leftmost_inorder(topmost_node.right)
        
        return topmost_node.val
    
    def hasNext(self):
        return len(self.stack) > 0
```

## 图论

### DFS 与 BFS
```python
from collections import deque

# 图的 DFS
def dfs_graph(adj_list, start):
    visited = set()
    result = []
    
    def dfs(node):
        if node in visited:
            return
        
        visited.add(node)
        result.append(node)
        
        for neighbor in adj_list[node]:
            dfs(neighbor)
    
    dfs(start)
    return result

# 图的 BFS
def bfs_graph(adj_list, start):
    visited = set([start])
    queue = deque([start])
    result = []
    
    while queue:
        node = queue.popleft()
        result.append(node)
        
        for neighbor in adj_list[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return result
```

### 并查集
```python
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.count = n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False
        
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
        
        self.count -= 1
        return True
    
    def connected(self, x, y):
        return self.find(x) == self.find(y)
```

## 复杂度总结

| 数据结构 | 访问 | 搜索 | 插入 | 删除 | 适用场景 |
|----------|------|------|------|------|----------|
| 数组 | O(1) | O(n) | O(n) | O(n) | 随机访问，数据量固定 |
| 链表 | O(n) | O(n) | O(1) | O(1) | 频繁插入删除 |
| 哈希表 | O(1) | O(1) | O(1) | O(1) | 快速查找 |
| 二叉搜索树 | O(log n) | O(log n) | O(log n) | O(log n) | 有序数据 |
| 最小堆 | O(1) | O(log n) | O(log n) | O(log n) | 优先级队列 |