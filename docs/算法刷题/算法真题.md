# å¤§å‚é¢è¯•çœŸé¢˜åˆ†æä¸è§£ç­”

## å­—èŠ‚è·³åŠ¨é«˜é¢‘é¢˜

### 1. å­—ç¬¦ä¸²æ’åˆ— (å‰‘æŒ‡ Offer 38)
```python
def permutation(s):
    """
    å›æº¯ + å‰ªæ
    æ—¶é—´å¤æ‚åº¦: O(n Ã— n!)
    ç©ºé—´å¤æ‚åº¦: O(nÂ²)
    """
    result = []
    chars = list(s)
    
    def backtrack(index):
        if index == len(chars) - 1:
            result.append(''.join(chars))
            return
        
        seen = set()
        for i in range(index, len(chars)):
            if chars[i] in seen:
                continue
            seen.add(chars[i])
            
            # äº¤æ¢ä½ç½®
            chars[index], chars[i] = chars[i], chars[index]
            backtrack(index + 1)
            # æ¢å¤ä½ç½®
            chars[index], chars[i] = chars[i], chars[index]
    
    backtrack(0)
    return result

# é¢è¯•è¦ç‚¹ï¼š
# 1. å¦‚ä½•å¤„ç†é‡å¤å­—ç¬¦ï¼ˆå‰ªæï¼‰
# 2. å›æº¯ç®—æ³•çš„æ­£ç¡®æ€§
# 3. æ—¶é—´å¤æ‚åº¦åˆ†æ
```

### 2. LRU ç¼“å­˜æœºåˆ¶
```python
class ListNode:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}
        self.head = ListNode()
        self.tail = ListNode()
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def _add_node(self, node):
        """åœ¨å¤´éƒ¨æ·»åŠ èŠ‚ç‚¹"""
        node.prev = self.head
        node.next = self.head.next
        
        self.head.next.prev = node
        self.head.next = node
    
    def _remove_node(self, node):
        """ç§»é™¤èŠ‚ç‚¹"""
        prev_node = node.prev
        next_node = node.next
        
        prev_node.next = next_node
        next_node.prev = prev_node
    
    def _move_to_head(self, node):
        """ç§»åŠ¨åˆ°å¤´éƒ¨"""
        self._remove_node(node)
        self._add_node(node)
    
    def _pop_tail(self):
        """å¼¹å‡ºå°¾éƒ¨èŠ‚ç‚¹"""
        node = self.tail.prev
        self._remove_node(node)
        return node
    
    def get(self, key):
        node = self.cache.get(key)
        if not node:
            return -1
        
        self._move_to_head(node)
        return node.value
    
    def put(self, key, value):
        node = self.cache.get(key)
        
        if not node:
            new_node = ListNode(key, value)
            self.cache[key] = new_node
            self._add_node(new_node)
            
            if len(self.cache) > self.capacity:
                tail = self._pop_tail()
                del self.cache[tail.key]
        else:
            node.value = value
            self._move_to_head(node)

# é¢è¯•è¦ç‚¹ï¼š
# 1. å“ˆå¸Œè¡¨ + åŒå‘é“¾è¡¨çš„è®¾è®¡
# 2. æ—¶é—´å¤æ‚åº¦ O(1)
# 3. çº¿ç¨‹å®‰å…¨æ€§è€ƒè™‘
```

## è…¾è®¯é«˜é¢‘é¢˜

### 3. ç¯å½¢é“¾è¡¨ II
```python
def detect_cycle(head):
    """
    å¿«æ…¢æŒ‡é’ˆ + æ•°å­¦æ¨å¯¼
    æ—¶é—´å¤æ‚åº¦: O(n)
    ç©ºé—´å¤æ‚åº¦: O(1)
    """
    if not head or not head.next:
        return None
    
    slow = fast = head
    
    # ç¬¬ä¸€é˜¶æ®µï¼šåˆ¤æ–­æ˜¯å¦æœ‰ç¯
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            break
    else:
        return None  # æ— ç¯
    
    # ç¬¬äºŒé˜¶æ®µï¼šæ‰¾åˆ°ç¯çš„å…¥å£
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    
    return slow

# æ•°å­¦æ¨å¯¼ï¼š
# è®¾å¤´èŠ‚ç‚¹åˆ°ç¯å…¥å£è·ç¦»ä¸º aï¼Œç¯å…¥å£åˆ°ç›¸é‡ç‚¹è·ç¦»ä¸º bï¼Œç›¸é‡ç‚¹åˆ°ç¯å…¥å£è·ç¦»ä¸º c
# å¿«æŒ‡é’ˆè·¯ç¨‹ = a + n(b+c) + b
# æ…¢æŒ‡é’ˆè·¯ç¨‹ = a + b
# 2(a+b) = a + n(b+c) + b
# => a = (n-1)(b+c) + c
```

### 4. æœç´¢æ—‹è½¬æ’åºæ•°ç»„
```python
def search(nums, target):
    """
    äºŒåˆ†æŸ¥æ‰¾å˜ç§
    æ—¶é—´å¤æ‚åº¦: O(log n)
    ç©ºé—´å¤æ‚åº¦: O(1)
    """
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        
        # åˆ¤æ–­å“ªéƒ¨åˆ†æ˜¯æœ‰åºçš„
        if nums[left] <= nums[mid]:  # å·¦åŠéƒ¨åˆ†æœ‰åº
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:  # å³åŠéƒ¨åˆ†æœ‰åº
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1

# é¢è¯•è¦ç‚¹ï¼š
# 1. äºŒåˆ†æŸ¥æ‰¾çš„å˜ç§åº”ç”¨
# 2. å¦‚ä½•åˆ¤æ–­æœ‰åºåŒºé—´
# 3. è¾¹ç•Œæ¡ä»¶å¤„ç†
```

## é˜¿é‡Œå·´å·´é«˜é¢‘é¢˜

### 5. æœ€å°æ ˆ
```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []  # è¾…åŠ©æ ˆå­˜å‚¨æœ€å°å€¼
    
    def push(self, val):
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)
    
    def pop(self):
        if self.stack.pop() == self.min_stack[-1]:
            self.min_stack.pop()
    
    def top(self):
        return self.stack[-1] if self.stack else None
    
    def getMin(self):
        return self.min_stack[-1] if self.min_stack else None

# é¢è¯•è¦ç‚¹ï¼š
# 1. è¾…åŠ©æ ˆçš„è®¾è®¡æ€æƒ³
# 2. æ—¶é—´å¤æ‚åº¦ O(1)
# 3. ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–
```

### 6. å²›å±¿æ•°é‡
```python
def num_islands(grid):
    """
    DFS è§£æ³•
    æ—¶é—´å¤æ‚åº¦: O(m Ã— n)
    ç©ºé—´å¤æ‚åº¦: O(m Ã— n)
    """
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    count = 0
    
    def dfs(i, j):
        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':
            return
        
        grid[i][j] = '0'  # æ ‡è®°ä¸ºå·²è®¿é—®
        
        # å››ä¸ªæ–¹å‘DFS
        dfs(i + 1, j)
        dfs(i - 1, j)
        dfs(i, j + 1)
        dfs(i, j - 1)
    
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                count += 1
                dfs(i, j)
    
    return count

# BFS è§£æ³•
from collections import deque

def num_islands_bfs(grid):
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    count = 0
    
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                count += 1
                queue = deque([(i, j)])
                grid[i][j] = '0'
                
                while queue:
                    x, y = queue.popleft()
                    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == '1':
                            queue.append((nx, ny))
                            grid[nx][ny] = '0'
    
    return count
```

## é¢è¯•æŠ€å·§æ€»ç»“

### è§£é¢˜æ€è·¯æ¨¡æ¿
```python
def solve_problem(input):
    # 1. ç†è§£é—®é¢˜ï¼Œç¡®è®¤è¾“å…¥è¾“å‡º
    # 2. è€ƒè™‘è¾¹ç•Œæƒ…å†µ
    if not input:
        return default_value
    
    # 3. é€‰æ‹©åˆé€‚çš„æ•°æ®ç»“æ„
    data_structure = initialize_structure()
    
    # 4. è®¾è®¡ç®—æ³•æ­¥éª¤
    for item in input:
        process_item(item)
    
    # 5. åˆ†ææ—¶é—´ç©ºé—´å¤æ‚åº¦
    return result
```

### å¸¸è§é—®é¢˜ç±»å‹
| é—®é¢˜ç±»å‹ | è§£é¢˜æ€è·¯ | ç»å…¸é¢˜ç›® |
|----------|----------|----------|
| æ•°ç»„/å­—ç¬¦ä¸² | åŒæŒ‡é’ˆã€æ»‘åŠ¨çª—å£ã€å“ˆå¸Œè¡¨ | ä¸¤æ•°ä¹‹å’Œã€æ— é‡å¤å­—ç¬¦ |
| é“¾è¡¨ | å¿«æ…¢æŒ‡é’ˆã€è™šæ‹Ÿå¤´èŠ‚ç‚¹ | åè½¬é“¾è¡¨ã€ç¯å½¢æ£€æµ‹ |
| æ ‘ | é€’å½’ã€è¿­ä»£ã€å±‚æ¬¡éå† | äºŒå‰æ ‘éå†ã€éªŒè¯BST |
| åŠ¨æ€è§„åˆ’ | çŠ¶æ€å®šä¹‰ã€è½¬ç§»æ–¹ç¨‹ | æœ€é•¿å­åºåˆ—ã€èƒŒåŒ…é—®é¢˜ |
| å›æº¯ | é€‰æ‹©åˆ—è¡¨ã€è·¯å¾„ã€ç»“æŸæ¡ä»¶ | å…¨æ’åˆ—ã€Nçš‡å |
| å›¾è®º | DFSã€BFSã€å¹¶æŸ¥é›† | å²›å±¿æ•°é‡ã€è¯¾ç¨‹è¡¨ |

### é¢è¯•æ³¨æ„äº‹é¡¹
1. **æ²Ÿé€šäº¤æµ**ï¼šå…ˆç†è§£é¢˜æ„ï¼Œå†ç»™å‡ºæ€è·¯
2. **ä»£ç è§„èŒƒ**ï¼šå˜é‡å‘½åã€æ³¨é‡Šã€è¾¹ç•Œå¤„ç†
3. **æµ‹è¯•ç”¨ä¾‹**ï¼šè€ƒè™‘æ­£å¸¸ã€è¾¹ç•Œã€ç‰¹æ®Šæƒ…å†µ
4. **ä¼˜åŒ–æ€è·¯**ï¼šä»æš´åŠ›è§£æ³•åˆ°æœ€ä¼˜è§£æ³•
5. **çŸ¥è¯†å¹¿åº¦**ï¼šäº†è§£ç›¸å…³æŠ€æœ¯æ ˆå’ŒåŸç†

> **ğŸ’¡ é¢è¯•å‡†å¤‡å»ºè®®**ï¼š
> - åˆ·é¢˜é‡ï¼š200-300 é“ç»å…¸é¢˜ç›®
> - é‡ç‚¹æŒæ¡ï¼šæ•°ç»„ã€å­—ç¬¦ä¸²ã€é“¾è¡¨ã€æ ‘ã€åŠ¨æ€è§„åˆ’
> - æ¨¡æ‹Ÿé¢è¯•ï¼šç»ƒä¹ è¡¨è¾¾å’Œæ²Ÿé€šèƒ½åŠ›
> - ç³»ç»Ÿè®¾è®¡ï¼šäº†è§£åˆ†å¸ƒå¼ã€æ•°æ®åº“ã€ç¼“å­˜ç­‰